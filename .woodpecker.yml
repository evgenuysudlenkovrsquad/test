# .woodpecker.yml
# ────────────────────────────────────────────────
# Триггер: push в develop или sandbox,
# исключая коммиты, затрагивающие только *.md
when:
  event: push
  branch: [develop, sandbox]
  path:
    exclude: ['**/*.md']

# Кэш Kaniko — ускоряет повторные сборки
volumes:
  - name: kaniko-cache
    temp: {}

steps:
# ────────────────────────────────────────────────
- name: init-vars
  image: alpine:3.19
  environment:
    KUBE_CONFIG:
      from_secret: kube_config
    APPS: '["indexer","relayer"]'
  commands:
    # Определяем STAGE и namespace по ветке
    - |
      case "$CI_COMMIT_BRANCH" in
        develop)
          echo "STAGE=develop"            >> .env
          echo "APP_NAMESPACE=ton-teleport-dev"  >> .env
          ;;
        sandbox)
          echo "STAGE=sandbox"            >> .env
          echo "APP_NAMESPACE=ton-teleport-sand" >> .env
          ;;
        *) exit 78 ;;          # неизвестная ветка → пропуск
      esac
      echo "SHORT_SHA=${CI_COMMIT_SHA:0:7}" >> .env

# ────────────────────────────────────────────────
- name: build-images
  image: gcr.io/kaniko-project/executor:debug
  depends_on: [init-vars]
  volumes:
    - name: kaniko-cache
      path: /kaniko/cache
  commands:
    - apk add --no-cache bash curl jq kubectl
    - source .env
    - echo "$KUBE_CONFIG" > kubeconfig.yaml
    - export KUBECONFIG=$PWD/kubeconfig.yaml
    - kubectl config use-context "$(kubectl config get-contexts -o name | head -n1)"

    # Достаём данные Docker-реестра из Kubernetes-секрета
    - |
      reg=$(kubectl -n "$APP_NAMESPACE" get secret docker-registry-creds \
            -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d)
      REG_URL=$(echo "$reg" | jq -r '.auths | to_entries[0].key')
      USER=$(echo "$reg" | jq -r '.auths | to_entries[0].value.username')
      PASS=$(echo "$reg" | jq -r '.auths | to_entries[0].value.password')

      # Kaniko читает логин из /kaniko/.docker/config.json
      mkdir -p /kaniko/.docker
      printf '{"auths": {"%s": {"username":"%s","password":"%s"}}}' \
             "$REG_URL" "$USER" "$PASS" > /kaniko/.docker/config.json

    # Канико-сборка/пуш для каждого приложения
    - |
      for app in $(echo "$APPS" | jq -r '.[]'); do
        echo "📦  Build $app"
        /kaniko/executor \
          --context "$PWD" \
          --dockerfile "$app/Dockerfile" \
          --destination "$REG_URL/${app}-${STAGE}:latest" \
          --destination "$REG_URL/${app}-${STAGE}:$SHORT_SHA" \
          --cache=true --cache-dir=/kaniko/cache
      done

# ────────────────────────────────────────────────
- name: deploy
  image: alpine/k8s:1.30.1           # kubectl + helm
  depends_on: [build-images]
  commands:
    - apk add --no-cache bash curl jq helm
    - source .env
    - echo "$KUBE_CONFIG" > kubeconfig.yaml
    - export KUBECONFIG=$PWD/kubeconfig.yaml
    - kubectl config use-context "$(kubectl config get-contexts -o name | head -n1)"

    # URL реестра снова извлекаем через kubectl
    - |
      reg=$(kubectl -n "$APP_NAMESPACE" get secret docker-registry-creds \
            -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d)
      REG_URL=$(echo "$reg" | jq -r '.auths | to_entries[0].key')

      failed=0
      for app in $(echo "$APPS" | jq -r '.[]'); do
        echo "⎈  Deploy $app"

        # секрета может не быть — добавляем параметр условно
        SECRET_OPT=""
        kubectl -n "$APP_NAMESPACE" get secret "${app}-secrets" &>/dev/null \
          && SECRET_OPT="--set secretName=${app}-secrets"

        VAL_OPT=""
        [ -f "${app}/${app}-${STAGE}.yml" ] && VAL_OPT="-f ${app}/${app}-${STAGE}.yml"

        helm upgrade --install "$app" ./helm \
          --namespace "$APP_NAMESPACE" \
          --set image.repository="$REG_URL/${app}-${STAGE}" \
          --set image.tag="$SHORT_SHA" \
          --set app.name="$app" \
          --set configMapName=envs-config \
          $SECRET_OPT $VAL_OPT \
          --atomic --timeout 5m --history-max 2 || failed=1
      done
      [ $failed -eq 0 ] || exit 1
